; Лиза П. Хакер не понимает, почему if должна быть особой формой. 
; «Почему нельзя просто определить ее как обычную процедуру с помощью cond?» — спрашивает она. 
; Лизина подруга Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую версию if:
(define (new-if predicate then-clause else-clause)
     (cond (predicate then-clause)
     (else else-clause))
)

(new-if (= 2 3) 0 5) //5
(new-if (= 1 1) 0 5) // 0

; вычисления квадратного корня:
(define (sqrt-iter guess x)
      (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)
     )
)
; Что получится, когда попытается использовать эту процедуру для вычисления квадратных корней? Объясните.

; Ответ: 
; Практичным путем определил что зацикливается. Теперь надо опеределить почему?
; Мое объяснение
; Так как интерпретатор использует аппликативный порядок (вычисляет операнды сначала) 
; при каждом вызове sqrt-iter будет вызываться sqrt-iter из new-if и след-но зацикливание

; Другое объяснение
; При вычислении new-if сначала должны быть вычислены все ее аргументы. 
; С первыми двумя из них проблем нет, а вот при вычислении третьего new-if снова обращается к sqrt-iter, 
; которая затем опять вызовет new-if… и так до бесконечности. Ограничивающего условия, обеспечивающего выход 
; из этого порочного круга, нет. Таким образом программа Лизы, переписанная в таком виде, зациклится.

; Почему же такой проблемы не возникает при использовании нормального if вместо new-if?
; Все просто. Обычный if является особой формой, он вычисляется не так, как стандартные процедуры. 
; Для вычисления его значения не обязательно будут вычислены все операнды 
; (более того, гарантированно будут вычислены только два из трех). 
; Таким образом sqrt-iter будет вычисляться только в случае, когда решение еще не достаточно хорошее, 
; а в противном случае вычисляться не будет, что и гарантирует выход из цикла