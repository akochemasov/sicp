; Проверка good-enough?, которую мы использовали для вычисления квадратных корней, будет довольно неэффективна 
; для поиска квадратных корней от очень маленьких чисел. Кроме того, в настоящих компьютерах арифметические 
; операции почти всегда вычисляются с ограниченнои точностью. Поэтому наш тест оказывается неадекватным и 
; для очень больших чисел. Альтернативный подход к реализации good-enough? состоит в том, чтобы следить, 
; как от одной итерации к другой изменяется guess, и остановиться, когда изменение оказывается небольшой 
; долей значения приближения. Разработайте процедуру вычисления квадратного корня, которая использует 
; такой вариант проверки на завершение. Верно ли, что на больших и маленьких числах она работает лучше?

; Перед тем, как что-то разрабатывать, как нас просят в упражнении, сначала убедимся в том, 
; что проблема, которую мы хотим преодолеть, путем усовершенствования кода, действительно существует.

(define (sqrt-iter guess x) 
  (if (good-enough? guess x) 
      guess 
      (sqrt-iter (improve guess x) 
                 x))
)
(define (good-enough? guess x) 
  (< (abs (- (square guess) x)) 0.001)
)
(define (square x) (* x x))
(define (improve guess x) 
  (average guess (/ x guess))
)
(define (average x y) 
  (/ (+ x y) 2)
)
(define (sqrt x) 
  (sqrt-iter 1.0 x)
)

; Вычислим sqrt для некоторых чисел:
> (sqrt 4) 
2.0000000929222947 
> (sqrt 100) 
10.000000000139897 
> (sqrt 0.01) 
0.10032578510960605 
> (sqrt 0.0001) 
0.03230844833048122 
> (sqrt 0.000001) 
0.031260655525445276 
> (sqrt 0.00000001) 
0.03125010656242753
; Видно, что проблема не надумана. На маленьких значениях аргумента функция вычисляет что угодно, 
; но только не его квадратный корень.

; Реализуем более точный вариант, как и сказано в условии упражнения. Доопределим недостающие функции:
(define (better-good-enough? guess prev-guess) 
  (< (abs (/ (- guess prev-guess) prev-guess)) 0.001)
)
(define (better-sqrt-iter guess prev-guess x) 
  (if (better-good-enough? guess prev-guess) 
      guess 
      (better-sqrt-iter (improve guess x) 
                        guess 
                        x))
)
(define (better-sqrt x) 
  (better-sqrt-iter 1.0 0.5 x)
)

; Произведем новые вычисления тех же значений с помощью усовершенствованной функции вычисления квадратного корня:
> (better-sqrt 4) 
2.0000000929222947 
> (better-sqrt 100) 
10.000000000139897 
> (better-sqrt 0.01) 
0.10000000000139897 
> (better-sqrt 0.0001) 
0.010000000025490743 
> (better-sqrt 0.000001) 
0.0010000001533016628 
> (better-sqrt 0.00000001) 
0.00010000000000082464
; Как видим, новая функция дает хорошие результаты и на малых значениях аргумента.

; Еще одно интересное наблюдение. Попробуйте вычислить что-то вроде (sqrt 1000000000000000). 
; У меня происходит зацикливание. Причина тому указана в условии упражнения. 
; В то же время (better-sqrt 1000000000000000) отрабатывает без каких-либо проблем и выдает неплохой результат.